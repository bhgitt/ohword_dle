import { times } from "lodash";
import { useCallback, useMemo, useState } from "react";
import axios from "axios";
import Head from "next/head";
import type { NextPage } from "next";
import Keyboard from "../components/Keyboard";

type Attempt = {
  letters: { char: string; result?: LetterStatus }[];
};

type GameStatus = "PLAYING" | "WON" | "LOST";

const Home: NextPage = () => {
  const [attempts, setAttempts] = useState<Attempt[]>(
    times(6, () => ({
      letters: [],
    }))
  );
  const [currentAttemptIndex, setCurrentAttemptIndex] = useState(0);
  const [letterHistory, setLetterHistory] = useState<LetterHistory[]>([]);

  const gameStatus: GameStatus = useMemo(() => {
    if (currentAttemptIndex > 6) {
      return "LOST";
    }
    if (
      attempts.find(
        (attempt) =>
          attempt.letters.filter(({ result }) => result === "GREEN").length ===
          5
      )
    ) {
      return "WON";
    }
    return "PLAYING";
  }, [attempts, currentAttemptIndex]);

  const submitAttempt = useCallback(async () => {
    const currentAttempt = attempts[currentAttemptIndex];
    try {
      if (currentAttempt.letters.length < 5) {
        throw new Error("incorrect-word-length");
      }
      const { data: attemptResult } = await axios.get<AttemptResponse>(
        "/api/attempt",
        {
          params: {
            word: currentAttempt.letters.reduce(
              (agg, char) => `${agg}${char.char}`,
              ""
            ),
          },
        }
      );
      setAttempts(
        attempts.map((attempt, index) => {
          if (index !== currentAttemptIndex) {
            return attempt;
          }
          return {
            letters: currentAttempt.letters.map((char, index) => {
              const result = attemptResult.letters[index].status;
              return {
                ...char,
                result,
              };
            }),
          };
        })
      );
      setCurrentAttemptIndex(currentAttemptIndex + 1);
      const newLetterHistory = [...letterHistory];
      attemptResult.letters.forEach((letter) => {
        if (newLetterHistory.find((history) => history.char === letter.char)) {
          return;
        }
        newLetterHistory.push({
          char: letter.char,
          result: letter.status,
        });
      });
      setLetterHistory(newLetterHistory);
    } catch (error) {
      alert(error);
    }
  }, [attempts, currentAttemptIndex, letterHistory]);

  return (
    <div>
      <Head>
        <title>Endy&apos;s Wordle</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className="bg-slate-50 min-h-screen flex flex-col">
        <div className="container px-8 mx-auto bg-white max-w-lg shadow-lg flex-1">
          <div className="py-8 flex flex-col space-y-2">
            {attempts.map((attempt, index) => {
              return (
                <div
                  className="flex space-x-2 justify-center"
                  key={`attempt-${index}`}
                >
                  {times(5, (charIndex) => {
                    const renderResultBlock = () => {
                      if (!attempt.letters[charIndex]?.result) {
                        return null;
                      }
                      const getBackgroundClassName = () => {
                        switch (attempt.letters[charIndex].result) {
                          case "GREEN":
                            return "bg-green-400";
                          case "YELLOW":
                            return "bg-yellow-400";
                          case "BLACK":
                          default:
                            return "bg-slate-100";
                        }
                      };
                      return (
                        <span
                          className={`absolute inset-0 ${getBackgroundClassName()}`}
                        />
                      );
                    };

                    const getBorderColor = () => {
                      if (!attempt.letters[charIndex]?.result) {
                        return "";
                      }
                      switch (attempt.letters[charIndex].result) {
                        case "GREEN":
                          return "border-green-500";
                        case "YELLOW":
                          return "border-yellow-500";
                        case "BLACK":
                        default:
                          return "border-slate-200";
                      }
                    };

                    return (
                      <div
                        className={`flex-1 aspect-square border-2 ${getBorderColor()} flex justify-center items-center relative rounded-lg overflow-hidden`}
                        key={`attempt-${index}-${charIndex}`}
                      >
                        {renderResultBlock()}
                        {!!attempt.letters[charIndex] && (
                          <span className="relative text-5xl font-bold text-slate-600">
                            {attempt.letters[charIndex].char}
                          </span>
                        )}
                      </div>
                    );
                  })}
                </div>
              );
            })}
          </div>
        </div>
        <Keyboard
          text={attempts[currentAttemptIndex].letters.reduce(
            (text, char) => `${text}${char.char}`,
            ""
          )}
          letterHistory={letterHistory}
          onChange={(newText) => {
            if (newText.length > 5 || gameStatus !== "PLAYING") {
              return;
            }
            setAttempts(
              attempts.map((attempt, index) => {
                if (index !== currentAttemptIndex) {
                  return attempt;
                }
                return {
                  letters: newText
                    .split("")
                    .map((newTextChar) => ({ char: newTextChar })),
                };
              })
            );
          }}
          onSubmit={submitAttempt}
        />
      </main>
    </div>
  );
};

export default Home;
